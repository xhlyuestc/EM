% !Mode:: "TeX:UTF-8"

\chapter{系统软件的设计与实现}
本文拟设计与的实现的病房语音呼叫系统，研究的重点除了硬件上的设计之外，再者就是软件上的创新。众所周之，任何一个自动化系统都是由硬件系统与软件系统两部分组成的。硬件是系统实现功能的基础，软件则是系统功能实现的核心。软件系统的可靠稳定性也将对系统的整体性能产生重要影响。

本系统的设计特别考虑了在不同的工作环境下，如何保证病房语音呼叫系统正常工作，这就要求系统要具备强健的抗干扰能力。此系统的抗干扰问题的解决与抗干扰功能的设计也就成为了软件系统设计的重要内容。通常来讲，监测系统上的抗干扰设计既可以通过硬件来实现，也可以通过软件来实现。本文探讨的重点是如何通过软件和硬件结合来解决系统的抗干扰问题。

\section{系统嵌入式软件的设计与实现}
\subsection{RT-Thread嵌入式实时操作系统简介}
RT-Thread是一个开放源代码的实时操作系统，并且商业许可证非常宽松的实时操作系统。图~\ref{rtt.png}是RT-Thread及外围组件的基本框架图\footnote{图取自《RT-Thread实时操作系统编程指南0.3.0》P25}：
\pic[htbp]{RT-Thread及外围组件基本框架}{}{rtt.png}

RT-Thread Kernel内核部分包括了RT-Thread的核心代码，包括对象管理器，线程管理及调度，线程间通信等的微小内核实现（最小能够到达4k ROM，1k RAM体积占用）。内核库是为了保证内核能够独立运作的一套小型类似C库实现（这部分根据编译器自带C库的情况会有些不同，使用GCC编译器时，携带更多的标准C库实现）。CPU及板级支持包包含了RT-Thread支持的各个平台移植代码，通常会包含两个汇编文件，一个是系统启动初始化文件，一个是线程进行上下文切换的文件，其他的都是C源文件。

RT-Thread实时操作系统核心是一个高效的硬实时核心，它具备非常优异的实时性、稳定性、可剪裁性。最小可以到3k ROM占用、1k RAM占用。

\subsubsection{内核对象系统}
实时线程操作系统内部采用面向对象的方式设计，内建内核对象管理系统，能够访问/管理所有内核对象。内核对象包含了内核中绝大部分设施，而这些内核对象可 以是静态分配的静态对象，也可以是从系统内存堆中分配的动态对象。通过内核对象系统，RT-Thread可以做到不依赖于具体的内存分配方式，伸缩性得到 极大的加强。

\subsubsection{任务/线程调度}
支持以线程为基本调度单位的多任务系统。调度算法是基于优先级的全抢占式线程调度，支持256个线程优先级（亦可配置成32个线程优先级），0优先级代表 最高优先级，255优先级留给空闲线程使用；相同优先级上支持多个线程，这些相同优先级的线程采用可设置时间片长度的时间片轮转调度；调度器寻找下一个最 高优先级就绪线程的时间是恒定的(O(1))。系统不限制线程数量的多少，只与物理平台的具体内存相关。

\subsubsection{同步机制}
系统支持semaphore，mutex等线程间同步机制。mutex采用优先级继存方式以防止优先级翻转。semaphore释放动作可安全用于中断服 务例程中。同步机制支持线程按优先级等待或按先进先出方式获取信号量或互斥锁。

\subsubsection{通信机制}
系统支持event，mailbox，message queue通信机制等。event支持多事件"或触发"及"与触发"，适合于线程等待多个事件情况。mailbox中一个mail的长度固定为4字节，效率较messagequeu高。通信设施中的发送动作可安全用于中断服务例程中。通信机制支持线程按优先级等待或按先进先出方式获取。

\subsubsection{时钟/定时器}
系统默认使用时钟节拍来完成同优先级任务的时间片轮转调度；线程对内核对象的时间敏感性是通过系统定时器来实现的；定时器又分成了硬定时器和软定时器，一 次定时及周期性定时。

\subsubsection{内存管理}
系统支持静态内存池管理及动态内存堆管理。从静态内存池中获取/释放内存块时间恒定，而当内存池空时，可根据申请线程请求把申请线程挂起、立刻返回、或等 待一段时间仍未获得返回。当其他线程释内存块到内存池时，将把挂起的线程唤醒。对于系统内存紧张的系统，RT-Thread也提供了小型的伙伴内存管理算 法。而对于拥有大一些内存的嵌入式系统，RT-Thread提供了性能非常高效的SLAB内存管理系统。

\subsubsection{诊断}
通过系统提供的FinSH shell系统，能够查看到线程，信号量，互斥锁，事件，邮箱，消息队列的运行情况，以及各个线程的栈使用情况。

\subsection{RT-Thread在STM32上的移植与配置}
ARM{\reg} Cortex{\reg}-M3微处理器可以说是和ARM7TDMI微处理器完全不同的体系结构，在进行RT-Thread移植时首先需要把线程的上下文切换移植好。通常的ARM移植，RT-Thread需要手动的保存当前模式下几乎所有寄存器，R0 – R13，LR，PC，CPSR，SPSR等。在Cortex{\reg}-M3微处理器中，则不需要保存全部的寄存器到栈中，因为当一个异常触发时，Cortex{\reg}-M3硬件能够自动的完成部分的寄存器保存。

当要进行切换时（假设从Thread [from] 切换到Thread [to]），通过 rt{\_}hw{\_}context{\_}switch 函数触发一个PenSV异常。异常产生时，Cortex{\reg}-M3会把PSR，PC，LR，R0 – R3，R12自动压入当前线程的栈中，然后切换到PenSV异常处理。到PenSV异常后，Cortex{\reg}-M3工作模式切换到Handler模式，由函数rt{\_}hw{\_}pend{\_}sv进行处理。rt{\_}hw{\_}pend{\_}sv函数会载入切换出线程和切换到线程的栈指针，如果切换出线程的栈指针是0那么表示这是第一次线程上下文切换，不需要对切换出线程做压栈动作。如果切换出线程栈指针非零，则把剩余未压栈的R4 – R11寄存器依次压栈；然后从切换到线程栈中恢复R4 – R11寄存器。当从PendSV异常返回时，PSR，PC，LR，R0 – R3，R12等寄存器由Cortex{\reg} M3自动恢复。

当中断达到时，当前线程会被中断并把PC，PSR，R0 – R3，R12等压到当前线程栈中，工作模式切换到Handler模式。在运行中断服务例程期间， 如果发生了线程切换（调用rt{\_}schedule）， 会先判断当前工作模式是否是Handler模式（依赖于全局变量rt{\_}interrupt{\_}nest）， 如果是则调用rt{\_}hw{\_}context{\_}switch{\_}interrupt函数进行伪切换：

在rt{\_}hw{\_}context{\_}switch{\_}interrupt函数中， 将把当前线程栈指针赋值到 rt{\_}interrupt{\_}from{\_}thread 变量上， 把要切换过去的线程栈指针赋值到 rt{\_}interrupt{\_}to{\_}thread 变量上， 并设置中断中线程切换标志 rt thread{\_}switch{\_}interrput{\_}flag 为1。

在最后一个中断服务例程结束时，Cortex{\reg}-M3将去处理PendSV异常，因为PendSV异常的优先级是最低的，所以只有触发过PendSV异常，它将总是在最后进行处理。

这里就不进一步详细讨论RT-Thread在STM32上的移植了。事实上，RT-Thread开发组已经做了好STM32系列微控制器的大部分移植工作，从官网下载源码后作简单修改即可完成符合自身硬件的移植工作。

前面讨论了，嵌入式操作系统是有很高的可裁剪性的，RT-Thread也不例外，通过启用或者关闭rtconfig.h头文件中的宏定义就可以很方便地保留或者裁剪系统的功能代码。本系统中将保留RT-Thread的默认配置选项：
\begin{itemize}
\item 线程优先级支持，32优先级
\item 内核对象支持命名，4字符
\item 操作系统节拍单位，10毫秒（100拍/秒）
\item 支持钩子函数
\item 支持信号量、互斥锁
\item 支持事件、邮箱、消息队列
\item 支持内存池
\item 支持RT-Thread自带的动态堆内存分配器
\end{itemize}

\subsection{系统嵌入式软件的总体框架}
\pic[htbp]{系统嵌入式软件的总体框架}{width=0.5\textwidth}{embsw_block.pdf}

\subsection{建立系统主要线程}
本应用中嵌入式系统主要有两个线程：LED指示灯线程和UDP通信线程。采用事件驱动方式：无事件发生时系统空闲，执行操作系统的自带的idle线程；有事件发生时发送信号量或者消息完成进程间同步。

\subsubsection{LED指示灯线程}
为LED线程分配堆栈和声明线程：\\
\input{chapters/rtt_led_declaration.c.tex}

定义LED线程入口并完成功能程序：\\
\input{chapters/rtt_led_thread.c.tex}

在rt{\_}application{\_}init()中初始化并启动LED线程：\\
\input{chapters/rtt_led_init.c.tex}
以上程序专门创建了一个“init”线程用来对其他用户线程完成初始化工作。

\subsubsection{UDP通信线程}
为UDP通信线程分配堆栈和声明线程：\\
\input{chapters/rtt_udp_declaration.c.tex}

定义UDP通信线程入口并完成功能程序：\\
\input{chapters/rtt_udp_thread.c.tex}

在rt{\_}init{\_}thread{\_}entry{}中初始化并启动UDP线程：\\
\input{chapters/rtt_udp_init.c.tex}

\subsection{按键中断服务程序}
配置按键对应的IO引脚为带外部中断的输入模式:\\
\input{chapters/key_io_init.c.tex}

使能按键对应的外部中断线，并配置为上升沿或下降沿触发中断:\\
\input{chapters/key_exti_init.c.tex}

配置按键对应外部中断的优先级:\\
\input{chapters/key_nvic_init.c.tex}

编写按键中断服务程序：\\
\input{chapters/key_isr.c.tex}

获取按键外部中断对应的事件类型：\\
\input{chapters/key_get_event.c.tex}

\subsection{语音输入驱动程序}
配置语音输入对应的IO引脚为模拟输入模式，配置\acrshort{ADC}的采样分辨率为8 bit，采样速率为8 KSPS，为\acrshort{ADC}启动DMA（\newacronym[description=直接存储访问]{DMA}{DMA}{Direct Memory Access}\acrlong{DMA}, 直接存储访问）传输，采集到的语音数据流将被\acrshort{DMA}交替地搬运到两个缓冲区：\\
\input{chapters/audio_input_init.c.tex}

\subsection{语音输出驱动程序}
配置语音输入对应的IO引脚为模拟输入模式，配置\acrshort{DAC}的采样分辨率为8 bit，转换速率为8 KSPS，为\acrshort{DAC}启动\acrshort{DMA}传输，从UDP服务端接收到的语音数据流将被交替地存储到两个缓冲区，\acrshort{DMA}则会按转换速率依次启动\acrshort{DAC}将数据流转换成对应的模拟语音信号输出：\\
\input{chapters/audio_output_init.c.tex}

语音通话建立后开启语音输入输出功能：\\
\input{chapters/audio_on.c.tex}

语音通话结束后关闭语音输入输出功能：\\
\input{chapters/audio_off.c.tex}

\subsection{WIFI模块驱动程序}
由于WIFI模块驱动程序非常庞大，在此仅示意性地给出WIFI初始化顶层API的部分程序：\\
\input{chapters/wifi_init.c.tex}

至此，嵌入式软件的设计与实现部分阐述完毕。

\section{系统上位机软件的设计与实现}
\subsection{开发工具简介}
病房语音呼叫系统的上位机软件拟采用Visual C{\#}集成开发环境来设计和完成。Visual C{\#}是美国Microsoft公司设计和推出的一款面向Windows操作系统的可视化编程工具，它不需要开发者编写大量的程序代码，常用的工具都是以控件的方式集成在开发包当中，当用户需要使用相关的控件时，只需要将控件拖到相对应的位置即可。Visual C{\#}的最大优势是比较容易上手，开发者无论是刚刚接触编程的初级开发人员，还是资深的程序员开发者，都可以很快掌握Visual C{\#}的开发方式和方法。使用Visual C{\#}来开发基于接近开关的测试系统上位机软件使得系统的风险得到了大大的降低，还使得整个系统的开发效率得到了极大的提高，系统的维护和升级也变得相对简单和容易。

Visual C{\#}的主要技术特点为：
\begin{enumerate}
\item 遵循面向对象的程序开发思想\\
Visual C{\#}循面向对象的程序开发思想其核心思想就是将复杂的系统设计分解成若干个具有独立功能且相对容易的对象集合。

\item 数据库交互能力十分强大\\
Visual C{\#}内部集成了多种数据访问控件，对于常规的ACCESS、SQL Service、Oracle等数据库都有相对应的控件，开发者在使用的时候只需要调用相关的控件即可完成对相关数据的读写等相关的操作。

\item 具有强大的事件驱动能力\\
Visual C{\#}具有强大的事件驱动能力，Visual {\#}是一种面向windows操作系统的开发工具，所以它可以很好的响应Windows环境下的各种事件等操作。

\item 采用结构化的编程风格\\
Visual C{\#}常用的工具都是以控件的方式集成在开发包当中，当用户需要使用相关的控件时，只需要将控件拖到相对应的位置即可。Visual C{\#}的最大优势是比较容易上手，开发者无论是刚刚接触编程的初级开发人员，还是资深的程序员开发者，都可以很快掌握Visual C{\#}的开发方式和方法。
\end{enumerate}

\subsection{上位机软件的主要框架}
医院病房语音呼叫系统在上位机软件设计过程中应该遵循系统兼容性好、开发周期短、操作简便等特点，故采用了C{\#}作为开发语言。病房语音呼叫系统在上位机软件可以完成对测试系统多种工作参数的编程设置以及对测试数据的读取。

病房语音呼叫系统的上位机软件功能结构如图~\ref{pcsw_block.pdf}~所示，从下到上按功能分为通信接口层、设备驱动层、中间件和数据库、应用层、用户接口层。最底层为通信接口层，上位机与嵌入式系统通过TCP/IP协议进行数据通信。设备驱动层负责语音输入输出设备的初始化、数据采集和转换、语音输出、网络设备控制等。中间件负责应用层和设备层之间的信息交换，数据库与中间件并列在中间层，顶层和底层需要长期存储的数据需要存储在数据库中时，也由中间件负责控制。应用层是语音呼叫系统上位机软件的各个核心功能模块所在层，所有应用模块通过中间件访问数据库或者底层设备，并将信息输出到用户界面。
\pic[htbp]{系统上位机软件的总体框架}{width=0.6\textwidth}{pcsw_block.pdf}

\subsection{通信接口层}
通信接口层主要负责上位机系统与语音呼叫终端之间的数据交换和通信链路管理，同时负责语音的输入与输出。由于上位机代码量极大，限于这里仅简要介绍部分程序或给出代码框架，并不一一罗列。

启动对话框程序时初始化并创建UDP通信连接：
\input{chapters/udp_client.c.tex}

程序启动时创建UDP接收线程，单击发送数据或者配置终端设备等按钮时，创建UDP发送线程：
\input{chapters/udp_client_thread.c.tex}

以下程序通过按钮开启或关闭UDP端口监听功能：
\input{chapters/udp_listen.c.tex}

\subsection{数据库管理层}
数据库管理层主要负责语音呼叫终端的参数、病房信息、病员信息、用药信息等数据的存储，以及以上信息的检索与重定位。

\subsection{图形化用户界面}
图形化用户界面是提供给用户的人机接口，负责接收用户的输入操作，并将相关信息作为结果反馈给用户。图形化用户界面应该做得极度简洁，一目了然，避免太过繁杂，否则反而不便于用户操作。基于这一准则设计的用户界面如图~\ref{gui.png}~所示。
\pic[htbp]{图形化用户界面}{width=1\textwidth}{gui.png}

用户界面为用户提供了每一个主功能模块的快捷按钮，并额外添加了一个快捷搜索按钮，用户可以通过搜索框输入关键词快速地进行信息检索。左侧以树状图显示了各个功能模块的层次信息，用户也可以通过展开功能树直接点击相应功能。考虑到各项工作的开展、记录和管理都离不开时间，特地在主界面添加了一个日历月视图。

\subsubsection{普通病房模块}
普通病房监护模块是对普通的医院住院功能模块进行管理，对普通病房进行巡检信息的管理，病人用药信息的管理以及基本信息管理，可以对病人的呼叫信息及时的回应。普通病房模块的功能框图见图~\ref{normal.pdf}。
\pic[htbp]{普通病房模块功能框图}{width=0.8\textwidth}{normal.pdf}

\subsubsection{重症病房模块}
重症监护病房模块是本系统重要的功能模块之一，也是医院住院病房重点关注的地方，该模块分为，病人信息、床位信息、用药信息等，可以随时的监护病人的情况，起到了重要的作用。重症病房模块的功能框图见图~\ref{icu.pdf}。
\pic[htbp]{重症病房模块功能框图}{width=0.8\textwidth}{icu.pdf}

\subsubsection{产房监护模块}
产房信息功能模块是语音系统中的重要模块，该模块中不仅要维护产妇的信息而且要及时的关注婴儿的信息，对产妇信息和婴儿信息进行双重的维护，是系统中重要的功能模块，具体功能模块图如图~\ref{birth.pdf}~所示。
\pic[htbp]{产房监护模块功能框图}{width=0.8\textwidth}{birth.pdf}

\subsubsection{系统管理模块}
系统管理模块是对整个系统的稳定运行以及数据进行管理，对数据进行管理，对语音进行管理，对病人的信息进行管理，对语音信息进行，对系统的日志进行管理以及对权限申请进行管理，可以对权限进行申请以及对系统日志进行管理。具体功能模块图如图~\ref{sys_mngr.pdf}~所示。
\pic[htbp]{系统管理模块功能框图}{width=0.8\textwidth}{sys_mngr.pdf}
	
\subsubsection{语音控制模块}
语音控制模块，可以对语音进行控制，比如对没有病人的病房或者是没有病人使用的床位可以控制改床位的语音呼叫系统不起作用，可以通过语音控制模块确认是哪个床位进行的呼叫，可以对语音进行存储，对语音进行确认，可以控制语音的开启以及关闭，是整个系统语音控制中枢，具体的功能模块图如图~\ref{audio.pdf}~所示。
\pic[htbp]{语音控制模块功能框图}{width=0.8\textwidth}{audio.pdf}

\subsubsection{信息查询模块}
系统还提供查询功能，对系统中的各种信息可以进行查询，系统提供查询功能，可以提供信息查询功能模块的报表打印以及病人信息进行查询，对语音信息查询，以及对病人的用药信息进行查询，通过对系统可以进行查询，具体功能如图~\ref{info.pdf}所示。
\pic[htbp]{信息查询模块功能框图}{width=0.8\textwidth}{info.pdf}

\section{本章小结}
本章主要完成了病房语音呼叫系统软件部分的详细设计与实现。首先对系统软件设计所应遵循的总体原则进行了介绍和说明，再以逐步推进的方式分别对系统嵌入式软件和上位机软件进行了设计阐述。嵌入式软件部分对操作系统、数据采集及处理等、UDP通信等进行了详细的论述。上位机软件部分对病房语音呼叫系统的主要框架和各个功能模块进行了阐述。
